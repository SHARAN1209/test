package com.bakerhughes.ruleapp.service.impl;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

import java.time.LocalDateTime;
import java.util.*;

import com.bakerhughes.ruleapp.entity.RuleAppTableVersionEntity;
import com.bakerhughes.ruleapp.repository.RuleAppTableVersionRepository;
import com.bakerhughes.ruleapp.repository.RuleappHistoricalDataRepository;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class DataPurgeServiceImplTest {

    @Mock
    private RuleAppTableVersionRepository tableVersionRepository;

    @Mock
    private RuleappHistoricalDataRepository historicalDataRepository;

    @InjectMocks
    private DataPurgeServiceImpl dataPurgeService;

    @BeforeEach
    void setup() {
        // Inject configuration values
        dataPurgeService.purgeSubversionDays = 10;
        dataPurgeService.purgeOlddataDays = 30;
    }

    private RuleAppTableVersionEntity buildEntity(String tableId, int version, int subVersion, boolean validityEnd) {
        RuleAppTableVersionEntity e = new RuleAppTableVersionEntity();
        e.setTableId(tableId);
        e.setVersion(version);
        e.setSubVersion(subVersion);
        e.setCreatedDate(LocalDateTime.now().minusDays(15));
        e.setValidityStart(LocalDateTime.now().minusDays(20));
        e.setValidityEnd(validityEnd ? LocalDateTime.now().minusDays(10) : null);
        return e;
    }

    // ✅ Case 1: No old sub-versions found (early return branch)
    @Test
    void testPurgeOldSubVersions_noOldSubVersions() {
        when(tableVersionRepository.findByCreatedDateBeforeAndSubVersionGreaterThan(any(), anyInt()))
                .thenReturn(Collections.emptyList());

        dataPurgeService.purgeOldSubVersions();

        verify(tableVersionRepository).findByCreatedDateBeforeAndSubVersionGreaterThan(any(), anyInt());
        verifyNoInteractions(historicalDataRepository);
    }

    // ✅ Case 2: Old sub-versions found, but only one record per version (no deletion)
    @Test
    void testPurgeOldSubVersions_oneRecordPerVersion() {
        RuleAppTableVersionEntity entity = buildEntity("T1", 1, 1, true);
        when(tableVersionRepository.findByCreatedDateBeforeAndSubVersionGreaterThan(any(), anyInt()))
                .thenReturn(List.of(entity));

        when(tableVersionRepository.findByTableIdAndVersionAndValidityEndIsNotNullOrderByValidityStartDesc("T1", 1))
                .thenReturn(List.of(entity));

        dataPurgeService.purgeOldSubVersions();

        verify(tableVersionRepository, times(1))
                .findByTableIdAndVersionAndValidityEndIsNotNullOrderByValidityStartDesc("T1", 1);
        verifyNoInteractions(historicalDataRepository);
        verify(tableVersionRepository, never()).delete(any());
    }

    // ✅ Case 3: Multiple sub-versions -> delete old ones
    @Test
    void testPurgeOldSubVersions_multipleRecords() {
        RuleAppTableVersionEntity latest = buildEntity("T1", 1, 3, true);
        RuleAppTableVersionEntity old1 = buildEntity("T1", 1, 2, true);
        RuleAppTableVersionEntity old2 = buildEntity("T1", 1, 1, true);

        when(tableVersionRepository.findByCreatedDateBeforeAndSubVersionGreaterThan(any(), anyInt()))
                .thenReturn(List.of(latest, old1, old2));

        when(tableVersionRepository.findByTableIdAndVersionAndValidityEndIsNotNullOrderByValidityStartDesc("T1", 1))
                .thenReturn(List.of(latest, old1, old2));

        dataPurgeService.purgeOldSubVersions();

        verify(historicalDataRepository, times(2)).deleteByTableIdAndVersion(eq("T1"), anyString());
        verify(tableVersionRepository, times(2)).delete(any());
    }

    // ✅ Case 4: No old records in purgeOldData
    @Test
    void testPurgeOldData_noRecords() {
        when(tableVersionRepository.findByValidityEndIsNotNullAndValidityStartBefore(any()))
                .thenReturn(Collections.emptyList());

        dataPurgeService.purgeOldData();

        verify(tableVersionRepository, times(1))
                .findByValidityEndIsNotNullAndValidityStartBefore(any());
        verifyNoInteractions(historicalDataRepository);
    }

    // ✅ Case 5: Old data exists and should be deleted
    @Test
    void testPurgeOldData_withRecords() {
        RuleAppTableVersionEntity e1 = buildEntity("T1", 1, 2, true);
        RuleAppTableVersionEntity e2 = buildEntity("T2", 2, 1, true);

        when(tableVersionRepository.findByValidityEndIsNotNullAndValidityStartBefore(any()))
                .thenReturn(List.of(e1, e2));

        dataPurgeService.purgeOldData();

        verify(historicalDataRepository, times(2))
                .deleteByTableIdAndVersion(anyString(), anyString());
        verify(tableVersionRepository, times(2)).delete(any());
    }
}
