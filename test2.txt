package com.bakerhughes.ruleapp.service.impl;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import com.bakerhughes.ruleapp.dto.BulkUploadFormColumn;
import com.bakerhughes.ruleapp.exception.ErrorCode;
import com.bakerhughes.ruleapp.exception.RuleAppServiceException;
import com.bakerhughes.ruleapp.service.DynamicTableService;

@Service
public class DynamicTableServiceImpl implements DynamicTableService {

    private static final Logger log = LoggerFactory.getLogger(DynamicTableServiceImpl.class);

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private DataSource dataSource;

    private static final String IDENTIFIER_REGEX = "^[A-Za-z][A-Za-z0-9_]*$";

    @Transactional
    public void truncateAndReloadTable(String tableName, List<Map<String, Object>> data,
            List<BulkUploadFormColumn> columns) {

        try (Connection conn = dataSource.getConnection()) {
            // Validate and get quoting char
            String quote = getIdentifierQuoteString(conn.getMetaData());

            // ensure table exists
            if (!StringUtils.hasText(tableName) || !isValidIdentifier(tableName)) {
                throw new RuleAppServiceException(ErrorCode.TABLE_RELOAD_FAILURE,
                        "Invalid table name: " + tableName, null, null, HttpStatus.BAD_REQUEST);
            }
            if (!tableExists(conn.getMetaData(), tableName)) {
                throw new RuleAppServiceException(ErrorCode.TABLE_RELOAD_FAILURE,
                        "Table not found: " + tableName, null, null, HttpStatus.BAD_REQUEST);
            }

            // Resolve columns: intersect requested and actual columns (preserves order of requested)
            List<String> allColumns = resolveAllColumnsFromMetadata(conn.getMetaData(), tableName, columns);

            if (allColumns.isEmpty()) {
                throw new RuleAppServiceException(ErrorCode.TABLE_RELOAD_FAILURE,
                        "No valid columns to insert for table: " + tableName, null, null, HttpStatus.BAD_REQUEST);
            }

            // Build safe SQL using quoted identifiers
            String quotedTable = quoteIdentifier(tableName, quote);
            String insertSql = buildSafeInsertSql(quotedTable, allColumns, quote);

            // Truncate - safe because table name was validated and exists and we used quoting
            jdbcTemplate.execute("TRUNCATE TABLE " + quotedTable);

            List<Object[]> batchArgs = data.stream()
                    .map(row -> mapRowValues(row, allColumns))
                    .toList();

            jdbcTemplate.batchUpdate(insertSql, batchArgs);

            log.info("Inserted {} rows into {}", data.size(), tableName);

        } catch (RuleAppServiceException re) {
            throw re; // rethrow our controlled exceptions
        } catch (Exception e) {
            log.error("Error in truncateAndReloadTable for {}: {}", tableName, e.getMessage(), e);
            throw new RuleAppServiceException(ErrorCode.TABLE_RELOAD_FAILURE,
                    String.format("Failed to truncateAndReloadTable data for %s", tableName), null, null,
                    HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    private List<String> resolveAllColumnsFromMetadata(DatabaseMetaData metaData, String tableName,
            List<BulkUploadFormColumn> columns) {
        // user-sent validated list (lowercased) but we'll only keep those present in DB
        List<String> requested = columns == null ? List.of()
                : columns.stream().map(BulkUploadFormColumn::getColumnName).filter(this::isValidIdentifier)
                        .map(String::toLowerCase).toList();

        List<String> required = getNonNullableColumnsFromMeta(metaData, tableName).stream()
                .map(String::toLowerCase).toList();

        // Build ordered set: requested first, then required if missing
        Set<String> all = new LinkedHashSet<>(requested);
        all.addAll(required);

        // Final: keep only columns that actually exist in the DB (case-insensitive)
        List<String> existing = getAllColumnsFromMeta(metaData, tableName).stream()
                .map(String::toLowerCase).toList();

        return all.stream().filter(existing::contains).toList();
    }

    private Object[] mapRowValues(Map<String, Object> row, List<String> allColumns) {
        return allColumns.stream().map(col -> row.getOrDefault(col, null)).toArray();
    }

    private String buildSafeInsertSql(String quotedTable, List<String> columns, String quote) {
        // Quote each column using DB-specific quote
        String colList = columns.stream().map(c -> quoteIdentifier(c, quote)).collect(Collectors.joining(", "));
        String placeholders = columns.stream().map(c -> "?").collect(Collectors.joining(", "));
        return String.format("INSERT INTO %s (%s) VALUES (%s)", quotedTable, colList, placeholders);
    }

    private boolean isValidIdentifier(String name) {
        return StringUtils.hasText(name) && name.matches(IDENTIFIER_REGEX);
    }

    private String quoteIdentifier(String identifier, String quote) {
        if (quote == null || quote.trim().isEmpty()) {
            // fallback to double-quote if DB didn't return anything
            quote = "\"";
        }
        return quote + identifier + quote;
    }

    private String getIdentifierQuoteString(DatabaseMetaData metaData) {
        try {
            String q = metaData.getIdentifierQuoteString();
            return q == null ? "\"" : q;
        } catch (Exception e) {
            log.warn("Could not determine identifier quote string from metadata, defaulting to double quotes", e);
            return "\"";
        }
    }

    private boolean tableExists(DatabaseMetaData metaData, String tableName) {
        try (ResultSet rs = metaData.getTables(null, null, tableName, new String[] { "TABLE" })) {
            return rs.next();
        } catch (Exception e) {
            log.error("Error checking table existence for {}: {}", tableName, e.getMessage());
            return false;
        }
    }

    private List<String> getAllColumnsFromMeta(DatabaseMetaData metaData, String tableName) {
        List<String> cols = new ArrayList<>();
        try (ResultSet rs = metaData.getColumns(null, null, tableName, null)) {
            while (rs.next()) {
                cols.add(rs.getString("COLUMN_NAME"));
            }
        } catch (Exception e) {
            log.error("Error reading columns for {}: {}", tableName, e.getMessage());
        }
        return cols;
    }

    private List<String> getNonNullableColumnsFromMeta(DatabaseMetaData metaData, String tableName) {
        List<String> cols = new ArrayList<>();
        try (ResultSet rs = metaData.getColumns(null, null, tableName, null)) {
            while (rs.next()) {
                int nullable = rs.getInt("NULLABLE"); // DatabaseMetaData.columnNoNulls/columnNullable
                if (nullable == DatabaseMetaData.columnNoNulls) {
                    cols.add(rs.getString("COLUMN_NAME"));
                }
            }
        } catch (Exception e) {
            log.error("Error reading non-nullable columns for {}: {}", tableName, e.getMessage());
        }
        return cols;
    }
}
