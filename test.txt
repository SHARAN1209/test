package com.bakerhughes.ruleapp.service.impl;

import com.bakerhughes.ruleapp.dto.BulkUploadFormColumn;
import com.bakerhughes.ruleapp.exception.ErrorCode;
import com.bakerhughes.ruleapp.exception.RuleAppServiceException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;
import org.springframework.jdbc.core.JdbcTemplate;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class DynamicTableServiceImplTest {

    @Mock
    private JdbcTemplate jdbcTemplate;

    @InjectMocks
    private DynamicTableServiceImpl service;

    private List<BulkUploadFormColumn> columns;

    @BeforeEach
    void setup() {
        BulkUploadFormColumn col1 = new BulkUploadFormColumn();
        col1.setColumnName("ID");

        BulkUploadFormColumn col2 = new BulkUploadFormColumn();
        col2.setColumnName("NAME");

        columns = List.of(col1, col2);
    }

    @Test
    void testTruncateAndReloadTable_success() {
        // Mock required columns from DB
        when(jdbcTemplate.queryForList(anyString(), eq(String.class), anyString()))
                .thenReturn(List.of("AGE"));

        // Prepare data
        Map<String, Object> row1 = new HashMap<>();
        row1.put("id", 1);
        row1.put("name", "Alice");
        row1.put("age", 25);

        Map<String, Object> row2 = new HashMap<>();
        row2.put("id", 2);
        row2.put("name", "Bob");
        row2.put("age", 30);

        List<Map<String, Object>> data = List.of(row1, row2);

        // Mock DB operations
        doNothing().when(jdbcTemplate).execute(anyString());
        when(jdbcTemplate.batchUpdate(anyString(), anyList())).thenReturn(new int[]{1, 1});

        // Execute public method
        service.truncateAndReloadTable("PersonTable", data, columns);

        // Verify interactions
        verify(jdbcTemplate, times(1)).execute("TRUNCATE TABLE PersonTable");
        verify(jdbcTemplate, times(1)).batchUpdate(contains("INSERT INTO PersonTable"), anyList());
    }

    @Test
    void testTruncateAndReloadTable_withDbError() {
        // Mock required columns
        when(jdbcTemplate.queryForList(anyString(), eq(String.class), anyString()))
                .thenReturn(List.of("AGE"));

        // Force truncate to throw error
        doThrow(new RuntimeException("DB error")).when(jdbcTemplate).execute(anyString());

        List<Map<String, Object>> data = List.of(Map.of("id", 1, "name", "John", "age", 30));

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> service.truncateAndReloadTable("PersonTable", data, columns));

        assertEquals(ErrorCode.TABLE_RELOAD_FAILURE, ex.getErrorCode());
        assertEquals(HttpStatus.INTERNAL_SERVER_ERROR, ex.getHttpStatus());
    }

    @Test
    void testTruncateAndReloadTable_invalidTableName() {
        // Table name is invalid -> getRequiredColumns should return empty
        List<Map<String, Object>> data = List.of(Map.of("id", 1, "name", "Invalid"));

        // No DB calls expected for required columns
        doNothing().when(jdbcTemplate).execute(anyString());
        when(jdbcTemplate.batchUpdate(anyString(), anyList())).thenReturn(new int[]{1});

        service.truncateAndReloadTable("123Invalid", data, columns);

        // Verify that queryForList was never called because of invalid table name
        verify(jdbcTemplate, never()).queryForList(anyString(), eq(String.class), anyString());
    }

    @Test
    void testTruncateAndReloadTable_requiredColumnsDbErrorHandled() {
        // Mock queryForList to throw DB error when fetching required columns
        when(jdbcTemplate.queryForList(anyString(), eq(String.class), anyString()))
                .thenThrow(new RuntimeException("DB error"));

        List<Map<String, Object>> data = List.of(Map.of("id", 1, "name", "ErrorCase"));

        doNothing().when(jdbcTemplate).execute(anyString());
        when(jdbcTemplate.batchUpdate(anyString(), anyList())).thenReturn(new int[]{1});

        // Even though required column fetch fails, main flow should continue
        service.truncateAndReloadTable("ValidTable", data, columns);

        verify(jdbcTemplate, times(1)).execute("TRUNCATE TABLE ValidTable");
        verify(jdbcTemplate, times(1)).batchUpdate(contains("INSERT INTO ValidTable"), anyList());
    }
}
