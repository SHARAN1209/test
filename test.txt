package com.bakerhughes.ruleapp.service;

import com.bakerhughes.ruleapp.entity.RuleAppTableVersionEntity;
import com.bakerhughes.ruleapp.repository.RuleAppHistoricalDataRepository;
import com.bakerhughes.ruleapp.repository.RuleAppTableVersionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class DataPurgeService {

    private final RuleAppTableVersionRepository tableVersionRepository;
    private final RuleAppHistoricalDataRepository historicalDataRepository;

    /**
     * Hourly purge job: Removes old sub-versions keeping the latest one.
     */
    @Scheduled(cron = "0 0 * * * *") // Run every hour
    @Transactional
    public void purgeOldSubVersions() {
        int configurableDays = 30; // configurable via properties or DB

        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(configurableDays);
        log.info("Starting purge of old sub-versions before cutoff date: {}", cutoffDate);

        // Step 1: Fetch old sub-versions
        List<RuleAppTableVersionEntity> oldSubVersions = tableVersionRepository.findOldSubVersions(cutoffDate);

        if (oldSubVersions.isEmpty()) {
            log.info("No old sub-versions found for cleanup.");
            return;
        }

        // Group by tableId -> version
        Map<String, Map<Integer, List<RuleAppTableVersionEntity>>> grouped = oldSubVersions.stream()
            .collect(Collectors.groupingBy(
                RuleAppTableVersionEntity::getTableId,
                Collectors.groupingBy(RuleAppTableVersionEntity::getVersion)
            ));

        // Step 2: Process each group
        grouped.forEach((tableId, versionMap) -> versionMap.forEach((version, records) -> {
            log.info("Processing tableId={} version={} with {} sub-versions", tableId, version, records.size());

            List<RuleAppTableVersionEntity> orderedRecords =
                    tableVersionRepository.findSubVersionsForTableAndVersion(tableId, version);

            if (orderedRecords.size() > 1) {
                List<RuleAppTableVersionEntity> toDelete = orderedRecords.subList(1, orderedRecords.size());

                for (RuleAppTableVersionEntity entity : toDelete) {
                    // Combine version and subVersion into one string like "1.2"
                    String combinedVersion = entity.getVersion() + "." + entity.getSubVersion();

                    // Delete related historical data first
                    historicalDataRepository.deleteByTableIdAndCombinedVersion(entity.getTableId(), combinedVersion);

                    // Then delete the sub-version record
                    tableVersionRepository.delete(entity);

                    log.info("Deleted sub-version {} (combinedVersion={}) for tableId={} version={}",
                             entity.getSubVersion(), combinedVersion, entity.getTableId(), entity.getVersion());
                }
            } else {
                log.info("No extra sub-versions to delete for tableId={} version={}", tableId, version);
            }
        }));

        log.info("Completed purge of old sub-versions.");
    }

    /**
     * Daily purge job: Removes old historical data and associated version records.
     */
    @Scheduled(cron = "0 0 0 * * *") // Run every day at midnight
    @Transactional
    public void purgeOldData() {
        int configurableDays = 90; // configurable via properties or DB

        LocalDateTime cutoffDate = LocalDateTime.now().minusDays(configurableDays);
        log.info("Starting purge of old data before cutoff date: {}", cutoffDate);

        // Step 1: Fetch old records
        List<RuleAppTableVersionEntity> oldRecords = tableVersionRepository.findOldRecords(cutoffDate);

        if (oldRecords.isEmpty()) {
            log.info("No old records found for purge.");
            return;
        }

        // Step 2: Remove historical data and table version entries
        for (RuleAppTableVersionEntity record : oldRecords) {
            // Combine version + subVersion
            String combinedVersion = record.getVersion() + "." + record.getSubVersion();

            // Delete historical data first
            historicalDataRepository.deleteByTableIdAndCombinedVersion(record.getTableId(), combinedVersion);

            // Then delete the version record
            tableVersionRepository.delete(record);

            log.info("Deleted historical and version record for tableId={} combinedVersion={}", 
                     record.getTableId(), combinedVersion);
        }

        log.info("Completed purge of old data.");
    }
}


package com.bakerhughes.ruleapp.repository;

import com.bakerhughes.ruleapp.entity.RuleappHistoricalDataEntity;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface RuleAppHistoricalDataRepository extends JpaRepository<RuleappHistoricalDataEntity, RuleappHistoricalDataEntity.PK> {

    /**
     * Deletes historical data using the combined version string like "1.2"
     */
    @Modifying
    @Query("DELETE FROM RuleappHistoricalDataEntity h " +
           "WHERE h.tableId = :tableId AND h.version = :combinedVersion")
    void deleteByTableIdAndCombinedVersion(@Param("tableId") String tableId,
                                           @Param("combinedVersion") String combinedVersion);
}

package com.bakerhughes.ruleapp.repository;

import com.bakerhughes.ruleapp.entity.RuleAppTableVersionEntity;
import org.springframework.data.jpa.repository.*;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface RuleAppTableVersionRepository extends JpaRepository<RuleAppTableVersionEntity, RuleAppTableVersionEntity.PK> {

    @Query("SELECT r FROM RuleAppTableVersionEntity r " +
           "WHERE r.createdDate < :cutoffDate AND r.subVersion > 0")
    List<RuleAppTableVersionEntity> findOldSubVersions(@Param("cutoffDate") LocalDateTime cutoffDate);

    @Query("SELECT r FROM RuleAppTableVersionEntity r " +
           "WHERE r.tableId = :tableId AND r.version = :version AND r.validityEnd IS NOT NULL " +
           "ORDER BY r.validityStart DESC")
    List<RuleAppTableVersionEntity> findSubVersionsForTableAndVersion(@Param("tableId") String tableId,
                                                                      @Param("version") Integer version);

    @Query("SELECT r FROM RuleAppTableVersionEntity r " +
           "WHERE r.validityEnd IS NOT NULL AND r.validityStart < :cutoffDate")
    List<RuleAppTableVersionEntity> findOldRecords(@Param("cutoffDate") LocalDateTime cutoffDate);
}

# Configurable purge periods
purge.subversion.days=30
purge.olddata.days=90

# Scheduler thread pool
spring.task.scheduling.pool.size=5

package com.bakerhughes.ruleapp.repository;

import com.bakerhughes.ruleapp.entity.RuleAppTableVersionEntity;
import com.bakerhughes.ruleapp.entity.RuleAppTableVersionEntity.PK;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface RuleAppTableVersionRepository extends JpaRepository<RuleAppTableVersionEntity, PK> {

    /**
     * Find old sub-versions where createdDate < cutoffDate and subVersion > 0
     */
    List<RuleAppTableVersionEntity> findByCreatedDateBeforeAndSubVersionGreaterThan(LocalDateTime cutoffDate, Integer subVersion);

    /**
     * Find sub-versions for a given tableId and version, where validityEnd is not null.
     * Results ordered by validityStart descending.
     */
    List<RuleAppTableVersionEntity> findByTableIdAndVersionAndValidityEndIsNotNullOrderByValidityStartDesc(String tableId, Integer version);

    /**
     * Find old records where validityEnd is not null and validityStart < cutoffDate
     */
    List<RuleAppTableVersionEntity> findByValidityEndIsNotNullAndValidityStartBefore(LocalDateTime cutoffDate);
}

package com.bakerhughes.ruleapp.repository;

import com.bakerhughes.ruleapp.entity.RuleappHistoricalDataEntity;
import com.bakerhughes.ruleapp.entity.RuleappHistoricalDataEntity.PK;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface RuleAppHistoricalDataRepository extends JpaRepository<RuleappHistoricalDataEntity, PK> {

    /**
     * Delete by tableId and combined version (e.g., "1.2")
     */
    void deleteByTableIdAndVersion(String tableId, String version);
}

