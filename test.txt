package com.bakerhughes.ruleapp.service.impl;

import com.bakerhughes.ruleapp.dto.LookUpTableResponse;
import com.bakerhughes.ruleapp.dto.RuleAppTableVersionResponse;
import com.bakerhughes.ruleapp.entity.LookUpTableEntity;
import com.bakerhughes.ruleapp.entity.RuleAppTableVersionEntity;
import com.bakerhughes.ruleapp.entity.RuleappHistoricalDataEntity;
import com.bakerhughes.ruleapp.exception.ErrorCode;
import com.bakerhughes.ruleapp.exception.RuleAppServiceException;
import com.bakerhughes.ruleapp.mapper.RuleAppServiceMapper;
import com.bakerhughes.ruleapp.repository.LookUpTableRepository;
import com.bakerhughes.ruleapp.repository.RuleAppTableVersionRepository;
import com.bakerhughes.ruleapp.repository.RuleappHistoricalDataRepository;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class RuleappDAOImplTest {

    @InjectMocks
    private RuleappDAOImpl ruleappDAO;

    @Mock
    private LookUpTableRepository lookUpTableRepository;

    @Mock
    private RuleAppTableVersionRepository ruleAppTableVersionRepository;

    @Mock
    private RuleappHistoricalDataRepository ruleappHistoricalDataRepository;

    @Mock
    private RuleAppServiceMapper ruleAppServiceMapper;

    @Mock
    private ObjectMapper objectMapper;

    private LookUpTableEntity tableEntity;
    private RuleAppTableVersionEntity versionEntity;
    private RuleappHistoricalDataEntity historicalDataEntity;

    @BeforeEach
    void setUp() {
        tableEntity = new LookUpTableEntity();
        tableEntity.setTableName("testTable");
        tableEntity.setDownloadableByGroups("[\"group1\",\"group2\"]");

        versionEntity = new RuleAppTableVersionEntity();
        versionEntity.setTableId("testTable");

        historicalDataEntity = new RuleappHistoricalDataEntity();
        historicalDataEntity.setTableId("testTable");
        historicalDataEntity.setVersion("v1");
        historicalDataEntity.setRecord("[{\"key\":\"value\"}]");
    }

    // =========================
    // getTablesByGroups Tests
    // =========================

    @Test
    void testGetTablesByGroups_Success() {
        List<LookUpTableEntity> entities = List.of(tableEntity);
        List<LookUpTableResponse> responseList = List.of(new LookUpTableResponse());

        when(lookUpTableRepository.findByGroups(anyList())).thenReturn(entities);
        when(ruleAppServiceMapper.mapTableInformationsToResponse(entities)).thenReturn(responseList);

        List<LookUpTableResponse> result = ruleappDAO.getTablesByGroups(List.of("group1"));

        assertEquals(1, result.size());
        verify(lookUpTableRepository, times(1)).findByGroups(anyList());
    }

    @Test
    void testGetTablesByGroups_NotFound() {
        when(lookUpTableRepository.findByGroups(anyList())).thenReturn(Collections.emptyList());

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> ruleappDAO.getTablesByGroups(List.of("group1")));

        assertEquals(ErrorCode.TABLES_NOT_FOUND, ex.getErrorCode());
        assertEquals(HttpStatus.NOT_FOUND, ex.getStatus());
    }

    // =========================
    // getVersions Tests
    // =========================

    @Test
    void testGetVersions_Admin_Success() {
        List<RuleAppTableVersionEntity> entities = List.of(versionEntity);
        when(ruleAppTableVersionRepository.findByTableIdOrderByValidityStartDesc("testTable"))
                .thenReturn(entities);
        when(ruleAppServiceMapper.mapTableVersionsToResponse(entities))
                .thenReturn(List.of(new RuleAppTableVersionResponse()));

        List<RuleAppTableVersionResponse> result = ruleappDAO.getVersions("testTable", true);

        assertEquals(1, result.size());
    }

    @Test
    void testGetVersions_NonAdmin_ReturnsLatestOnly() {
        RuleAppTableVersionEntity v1 = new RuleAppTableVersionEntity();
        RuleAppTableVersionEntity v2 = new RuleAppTableVersionEntity();
        List<RuleAppTableVersionEntity> entities = List.of(v1, v2);

        when(ruleAppTableVersionRepository.findByTableIdOrderByValidityStartDesc("testTable"))
                .thenReturn(entities);
        when(ruleAppServiceMapper.mapTableVersionsToResponse(anyList()))
                .thenReturn(List.of(new RuleAppTableVersionResponse()));

        List<RuleAppTableVersionResponse> result = ruleappDAO.getVersions("testTable", false);

        assertEquals(1, result.size());
        verify(ruleAppServiceMapper).mapTableVersionsToResponse(eq(List.of(v1)));
    }

    @Test
    void testGetVersions_NotFound() {
        when(ruleAppTableVersionRepository.findByTableIdOrderByValidityStartDesc("testTable"))
                .thenReturn(Collections.emptyList());

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> ruleappDAO.getVersions("testTable", true));

        assertEquals(ErrorCode.TABLE_NOT_FOUND, ex.getErrorCode());
        assertEquals(HttpStatus.NOT_FOUND, ex.getStatus());
    }

    // =========================
    // getItems Tests
    // =========================

    @Test
    void testGetItems_Success() throws Exception {
        // Table found
        when(lookUpTableRepository.findByTableName("testTable"))
                .thenReturn(Optional.of(tableEntity));

        // Valid downloadable groups JSON
        when(objectMapper.readValue(eq("[\"group1\",\"group2\"]"), any(TypeReference.class)))
                .thenReturn(List.of("group1", "group2"));

        // Historical data found
        when(ruleappHistoricalDataRepository.findByTableIdAndVersion("testTable", "v1"))
                .thenReturn(historicalDataEntity);

        List<Map<String, Object>> result = ruleappDAO.getItems("testTable", "v1", List.of("group1"));

        assertEquals(1, result.size());
        assertEquals("value", result.get(0).get("key"));
    }

    @Test
    void testGetItems_TableNotFound() {
        when(lookUpTableRepository.findByTableName("testTable")).thenReturn(Optional.empty());

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> ruleappDAO.getItems("testTable", "v1", List.of("group1")));

        assertEquals(ErrorCode.TABLE_NOT_FOUND, ex.getErrorCode());
    }

    @Test
    void testGetItems_UnauthorizedAccess_NoMatchingGroup() throws Exception {
        when(lookUpTableRepository.findByTableName("testTable"))
                .thenReturn(Optional.of(tableEntity));

        // Valid JSON, but user group doesn't match
        when(objectMapper.readValue(eq("[\"group1\",\"group2\"]"), any(TypeReference.class)))
                .thenReturn(List.of("group2"));

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> ruleappDAO.getItems("testTable", "v1", List.of("unauthorized")));

        assertEquals(ErrorCode.UNAUTHORIZED_DOWNLOAD_ACCESS, ex.getErrorCode());
        assertEquals(HttpStatus.UNAUTHORIZED, ex.getStatus());
    }

    @Test
    void testGetItems_UnauthorizedAccess_InvalidJson() throws Exception {
        when(lookUpTableRepository.findByTableName("testTable"))
                .thenReturn(Optional.of(tableEntity));

        // JSON parsing fails
        when(objectMapper.readValue(anyString(), any(TypeReference.class)))
                .thenThrow(new RuntimeException("JSON error"));

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> ruleappDAO.getItems("testTable", "v1", List.of("group1")));

        assertEquals(ErrorCode.UNAUTHORIZED_DOWNLOAD_ACCESS, ex.getErrorCode());
    }

    @Test
    void testGetItems_VersionNotFound() throws Exception {
        when(lookUpTableRepository.findByTableName("testTable"))
                .thenReturn(Optional.of(tableEntity));

        when(objectMapper.readValue(eq("[\"group1\",\"group2\"]"), any(TypeReference.class)))
                .thenReturn(List.of("group1"));

        // Version missing
        when(ruleappHistoricalDataRepository.findByTableIdAndVersion("testTable", "v1"))
                .thenReturn(null);

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> ruleappDAO.getItems("testTable", "v1", List.of("group1")));

        assertEquals(ErrorCode.VERSIONS_NOT_FOUND, ex.getErrorCode());
    }

    @Test
    void testGetItems_NullDownloadableGroups() throws Exception {
        // Covers `downloadableByGroups == null` branch
        tableEntity.setDownloadableByGroups(null);

        when(lookUpTableRepository.findByTableName("testTable"))
                .thenReturn(Optional.of(tableEntity));

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> ruleappDAO.getItems("testTable", "v1", List.of("group1")));

        assertEquals(ErrorCode.UNAUTHORIZED_DOWNLOAD_ACCESS, ex.getErrorCode());
    }

    @Test
    void testGetItems_NullUserGroups() throws Exception {
        // Covers `userGroups == null` branch
        when(lookUpTableRepository.findByTableName("testTable"))
                .thenReturn(Optional.of(tableEntity));

        RuleAppServiceException ex = assertThrows(RuleAppServiceException.class,
                () -> ruleappDAO.getItems("testTable", "v1", null));

        assertEquals(ErrorCode.UNAUTHORIZED_DOWNLOAD_ACCESS, ex.getErrorCode());
    }
}
